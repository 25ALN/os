## 操作系统真象还原
### 汇编/docker知识  
- 进制  
一个字含有 2 字节、16 比特；一个双字含有 4 字节、2 个字、32 比特。  
每一个字节都被编上了号且都是从0开始的
  
- 三个d命令  

    db	define byte	1字节	db 0x12 → 12h  

    dw	define word	2字节 dw 0x1234 → 34 12  

    dd	define double word	4字节	dd 0x12345678 → 78 56 34 12  
  
- inc 
对一个寄存器或内存操作数加 1。  
- jnz  
当 ZF（零标志）= 0 时跳转，也就是上一次比较或计算结果不为零时跳转。  
- jge  
当比较结果为**大于或等于（有符号数）**时跳转。
- $  
表示当前指令所在的地址  
- equ  
在汇编和链接过程中，标识符就等价于这个常量

 #### docker
    

inc 自增1,dec 自减1
### 第一章  
1.内存分段机制的原因  
解决程序的“位置无关性”问题  
**程序中使用的是 逻辑地址 = 段选择子 + 段内偏移，而不是物理地址。**  
**段基址由 段寄存器 提供，操作系统在装载时只需要设置好段寄存器的值，程序本身不用修改，就能在不同物理内存位置运行。**

支持模块化和保护

代码段、数据段、堆栈段分开，逻辑更清晰。

可以通过段描述符限制段的大小、权限（读/写/执行），提供基本保护。

方便多任务管理
不同任务有各自的段表，切换任务时只需要切换段寄存器即可，简化管理。  
- 偏移量  
可以从0000h 到 FFFFh（8086 的 16 位偏移全部取值）
![alt text](picture/image.png)
### 第二章(编写MBR主引导记录)
- 相关魔数  
0x55,0xaa是mbr最后的两个字节，方便bios去寻找  
0x7c00,是mbr所在的物理地址
- MBR
磁盘的第一个扇区(0 磁头 0 柱面 1 扇区)，用于存放 引导程序 和 磁盘分区表。  
当计算机启动时,BIOS 会将 MBR 加载到内存，然后执行其中的引导代码，以引导操作系统或引导加载程序
- BIOS
电脑主板上的一组 固件(Firmware),负责在计算机启动时 初始化硬件并引导操作系统。  
它存储在 ROM(EEPROM/Flash)芯片中，即使计算机关机也不会丢失
- 寄存器
CPU 内部的一小块存储单元，用于 存放数据、地址或控制信息，以便 CPU 快速访问和处理数据  
- 实模式
1. 地址空间有限制只能访问1MB的内存
2. 16位处理CPU一次只能处理两字节的数据
3. 任何程序都可以访问所有内存区域，没有隔离
4. CPU 只能执行一个程序（或任务），没有多任务处理能力
**内存访问**
```
内存的物理地址由 段地址 * 16 + 偏移地址 计算得出
```
- .s与.S结尾的区别
.s 文件是已经准备好的汇编代码
.S 文件是包含预处理指令的汇编代码，必须经过预处理器处理

### 第三章(完善MBR)  
- 有效地址  
指偏移地址
- vstart  
用于指定虚拟起始地址，其本身只是告诉编译器以新的数字作为后面数据的地址的起始值，它本身没改变数据本  
身在文件中的地址（相对于文件开头的偏移）
- 通用寄存器  
![alt text](<picture/截图 2025-09-15 20-45-59.png>)  
- LBA  
是操作系统访问磁盘的一种逻辑寻址方式，用连续编号代替物理地址，使得磁盘管理更简单、更统一、更高效
- ***实模式***下 CPU 内存寻址方式  
（1）寄存器寻址；     
```
指“数”在寄存器中，直接从寄存器中拿数据就行了  
mov ax, 0x10 
mov dx, 0x9 
mul dx 
以上三条指令都是寄存器寻址
```
（2）立即数寻址；   
```
能直接拿来立即使用的数被称为立即数，免去了寻找的这个过程
mov ax,0x18 
mov ds, ax 
第一条指令中的源操作数 0x18 是立即数，目的操作数 ax 是寄存器，所以它既是立即数寻址，也是寄存器寻址。
第二条指令中，源操作数和目的操作数都是寄存器，所以纯粹是寄存器寻址。
```
（3）内存寻址。   
```
操作数在内存中的寻址方式称为内存寻址。
```

在第三种内存寻址中又分为：  

（1）直接寻址；  
```
直接在操作数中给出的数字作为内存地址，通过中括号的形式告诉 CPU，取此地址中的值作为操作数
例如：

```

（2）基址寻址；   
```
在操作数中用 bx 寄存器或寄存器作为地址的起始，地址的变化以它为基础(只能用bx或bp寄存器作为基址寄存器，但在保护模式下可以有更多)
bx 寄存器的默认段寄存器是 DS，而 bp 寄存器的默认段寄存器是 SS

```
（3）变址寻址；  
```
变址寻址其实和基址寻址类似，只是寄存器由 bx、bp 换成了 si 和 di。si 是指源索引寄存器（source 
index），di 是指目的索引寄存器（destination index）。两个寄存器的默认段寄存器也是 ds
```

（4）基址变址寻址  
```
从名字上看，这是基址寻址和变址寻址的结合，即基址寄存器 bx 或 bp 加一个变址寄存器 si 或 di。如： 
mov [bx+di], ax 
add [bx+si], ax 
第一条指令是将 ax 中的值送入以 ds 为段基址，bx+di 为偏移地址的内存。第二条指令是将 ax 与[ds： 
bx+si]处的值相加后存入内存[ds：bx+si]。
```

- 颜色显示规则  
属性字节是 8 位（1 字节），常见规则：

| 位 7 | 位 6–4 | 位 3 | 位 2–0 |
|------|--------|------|--------|
| K    | BG     | I    | FG     |



位7 (K bit)：闪烁/跳动（1 = 闪烁，0 = 不闪烁）

位6–4 (BG)：背景色（3 位，可以表示 8 种颜色）

位3 (I)：前景色高亮位（亮度位）

位2–0 (FG)：前景色（低 3 位，8 种颜色）  
颜色表  
![alt text](<picture/截图 2025-09-18 20-26-18.png>)

```  
call  指令是一个流程转移指令，就是让程序执行的顺序发生短暂的改变，去执行别处地址上的指令，遇到ret指令后再回到原来的地方继续往下顺序执行，本质和jmp大同小异，区别是在jmp基础上增加了程序回到原来跳转处的功能。  

```

- 硬盘控制器主要的一些端口(也属于一种io接口)    

![alt text](<picture/截图 2025-09-24 19-10-03.png>)  
这些端口号是硬件中对应的寄存器的地址
### 第四章(初见保护模式)  

- 寻址方式变化  
段选择符 + 段描述符 + 段表
- 反转前缀  
```  
转换只是临时的，只在当前指令有效  
```  

1. 操作数大小反转前缀0x66  
将16位操作数转换为32位，以及将32位操作数转换为16位   
2. 寻址方式反转前缀0x67  
本质上就是将寄存器与当前环境相匹配，如在32位下使用ax就需要使用该反转前缀
  
- 段描述符格式  
![alt text](<picture/截图 2025-10-12 18-22-09.png>)
1.type  

- **段界限边界值**  
=（描述符中段界限+1）*段界限的粒度大小（4KB 或者 1）-1  
+1原因：是从0开始计数的，所以应该加上这开始的0  
-1原因：这是段的一个范围，0是起始，加上会越界

- 进入保护模式的步骤   
1. 关闭中断(防止在切换过程中触发中断导致切换失败)  
2. 加载GDT(建立段描述符，利用lgdt指针)  
3. 打开A20地址线  
4. 设置 CR0 寄存器的 PE 位(将CPU切换到保护模式)  
5. 立即执行远程跳转(jmp far)  
6. 在保护模式下重新加载寄存器(寄存器要开始使用选择子)  
7. 初始化栈等东西 

- 段类型的检查  
![alt text](<picture/截图 2025-10-20 15-57-49.png>)  

### 第五章(保护模式进阶 向内核迈进)  

- 利用BIOS中断0x15三种子功能获取内存的方法  
1. 0xe820  
返回内存布局，使用地址范围描述符(ARDS)来描述内存信息  
 (1) 填写好“调用前输入”中列出的寄存器。   
 
（2）执行中断调用 int 0x15。  

（3）在 CF 位为 0 的情况下，“返回后输出”中对应的寄存器便会有对应的结果。  

2. 0xe801  
返回内存容量，最大只能识别4GB内存  
（1）将 AX 寄存器写入 0xE801。   

（2）执行中断调用 int 0x15。  

（3）在 CF 位为 0 的情况下，“返回后输出”中对应的寄存器便会有对应的结果   

3. 0x88  
最大识别64MB的内存  
（1）将 AX 寄存器写入 0x88。   

（2）执行中断调用 int 0x15。   

（3）在 CF 位为 0 的情况下，“返回后输出”中对应的寄存器便会有对应的结果。  
  
- 二级页表虚拟地址到物理地址的转换  
![alt text](<picture/截图 2025-10-24 17-41-26.png>)  

| 名称 | 数值 | 说明 |
|------|------|------|
| 一页（Page） | 4KB | CPU MMU 最小映射单元 |
| 一页表（Page Table） | 4MB | 管理 1024 页 × 4KB |
| 一页目录（Page Directory） | 4GB | 管理 1024 页表 × 4MB |
049d981dcc65  

### 第六章  
对于gcc编译文件gcc -m32 -ffreestanding -nostdlib -nostdinc -c main.c -o main.o
上面那几个参数需要添加  
-ffreestanding：告诉编译器我们在写裸机程序；  

-nostdlib：不使用标准 C 库；  

-nostdinc：不包含标准头文件；  

### 第七章  
- 8259A  
管理来自外部设备的多个中断请求信号（IRQ），并按优先级将中断请求交给 CPU 处理。  
级联目的: 单个 8259A 芯片最多只能处理 8 个中断输入（IRQ0 ~ IRQ7）,但一个计算机系统往往需要处理 超过 8 个中断源。  
  
339~346 调试的演示后面可以再看


c语言所有库函数的实现 https://sourceware.org/git/?p=glibc.git;a=tree